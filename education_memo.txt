<<C언어>>

컴파일러, 포인터, 

빌드의 의미: 컴파일링에 성공해 컴퓨터가 이해할 수 있는 이진수로 만드는 것.
전처리기: 컴파일 이전 단계
함수: 표준함수와 사용자 정의 함수 두 종류.
긴 주석: /* */. 날짜, 작성자, 설명 등 기술.
함수 주석: 테스트용으로도 사용가능. 특정함수를 잠시 빼서 실행시키는 용도.
\n: 한 줄 씩 띄어쓰게 하기.

============================================================

<변수형>
변수: 변경이 가능한 수. 메모리 안에서 특정한 주소값을 가짐.하지만 모든 변수의 주소값을 기억할 수 없음. 따라서 의미있는 이름(변수명)을 부여하는 것임.
컴퓨터 구조: 디스크(프로그램), 메모리(프로세스)-RAM, CPU. CPU가 메모리와 데이터를 주고받을 때는 주소(포인터 변수)를 사용.
변수 선언의 기본 형태: 자료형-변수명(int-value)
코딩에서의 '='의 의미: 대입 ex) a = b => b가 a에 들어간다. 변수값이 변수에 들어가는 것.

int value; value = 100 (쓰레기 값을 100으로 변환) int value = 100(초기화 후 값 지정, 더 나음)

C언어에서 변수 지정 방식

1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성됩니다.

2. 변수의 이름은 숫자로 시작될 수 없습니다.

3. 변수의 이름 사이에는 공백을 포함할 수 없습니다.

4. 변수의 이름으로 C언어에서 미리 정의된 키워드(keyword)는 사용할 수 없습니다.

==============================================================

<자료형>

실수:double, 정수: int, 문자열: char.

*** 문자형과 문자열의 차이: 'A' = 문자형. 'Hello' = 문자열 ***

#{}:param이 자동적으로 string형태로 들어온다.
${}:param이 해당 컬럼의 자료형에 맞추어 파라미터의 자료형이 변경된다. 쿼리문으로 인식

상수: 변경 불가한 값. 메모리에 올라가 있음(연산 가능한 이유)

키보드(입력) => 메인보드 => 운영체제 => 프로그램

데이터의 주소값이란 해당 데이터가 저장된 메모리의 시작 주소를 의미한다.
주소변산자: &변수 => 변수의 데이터 주소를 보여줌(scanf_s)

**scanf_s("서식문자열(나타날 결과)", 변수) **

연산자: 정적인 데이터들을 유기적으로 행동하게 하여 새로운 가치를 창출해내는 것
- 대입 연산자: 대입연산자는 오른쪽에 있는 값을 왼쪽에 대입하는 역할을 한다. ex) a+=b => a = a + b
- 증감 연산자: 증가 연산자와 감소 연산자의 줄임말. ex) ++a: a의 값을 1 증가시킨 후 연산 진행. a++: 연산을 진행한 후 값을 1 증가시킨다.

*서식: 일정한 방식, 틀(함수)
서식 지정자: 변수를 이용하여 사용하는 지정자. 서식이 있을 때에만 변수를 옆에 적어준다. 서식이 없을 때는 따옴표 안의 내용만으로도 출력이 가능하다.

================================================================

<조건문>
- 조건을 최대한 촘촘하게 설정하자. 그렇지 않으면 내가 예상한 범위 밖의 값이 그대로 통과될 수도 있다. 
- 범위가 너무 넓으면 나누기를 통해서 그 범위를 축소하는 편이 좋다. ex)100점 => 100 / 10 = 10으로 축약(case10). if문과 swich문 모두에서 편리함.
- 홀수 짝수 구분 = 2로 나누었을 때 나머지가 0이면 짝수 1이면 홀수. 또는 a = a+ 2의 형태로 짝수만 나오게 유도할 수 있다.


 ================================================================

<반복문>
- for문, while문 매우 중요!!

**누적 계산법 => sum = sum + 변수**

=================================================================

<함수>
- void 함수는 결과값을 반환하지 않아서 다른 함수에서 결과값을 참조할 수 없다!! 쓰려면 main함수에서 void함수를 실행만 시켜주는 식으로 써야 한다!

====================================================================

<배열>
- 컴파일 시점에서 배열 안에 서식 문자를 쓰게 되면 그 문자의 값이 나중에 설정되는 경우에 컴파일러가 배열의 값을 인식하지 못한다. 따라서 c언어는 
 배열의 첫번째 요소를 무조건 0부터 시작하고, 인덱스도 0부터 시작한다.

- sizeof: 배열의 길이 구하는 연산자. ex) sizeof(int) = 4( bite크기로 계산함). sizeof(arr[3]) = 12; 배열의 길이 = sizeof(배열) / sizeof(배열[0]) => 전체 길이 / 한 요소의 길이. 

- 문자열: 문자열은 ""로 사용한다. 배열의 이름 == 주소값. 정의된 문자열은 변수 상태로 존재. 초기화 못시키기 때문에 일부러 null 값(\0)을 넣어 쓰레기값과 거리를 둠.유효 값만 인식. 
          
**인덱스의 길이는 5이지만 마지막 배열의 인덱스는 4이다!!**

- 배열의 이름 = 포인터. 배열의 첫 번째 주소값과 값이 같음. 다만 값을 변경할 수 없음(상수); 포인터를 배열처럼 사용. 

- 배열 이름을 포인터처럼 사용함. 포인터와 배열은 불가분 관계. 서로가 밀접하게 연결되어 있다.


======================================================================

<포인터>
-*는 포인터 변수를 지칭하는 기호. 이것을 쓰지 않으면 변수의 주소값을 받을 수 없다. 이 변수는 주소값과 변수의 실제값 둘 다 호출할 수 있다. 
 주소값을 호출할 때는 그냥 기호를 쓰고, 실제값을 호출할 때는 *를 붙여서 써준다. 

- &a는 a의 주소값을 가리킨다. 또한 배열의 이름은 배열의 첫번째 요소의 포인터를 의미한다. 

- 주소값은 기본적으로 정수값이다. 따라서 4바이트를 할당한다. 포인터 변수와 일반변수는 서로 자료형이 똑같아야 한다. 그렇지 않으면 실제값을 가져올 수 없다.

*** 프로그래밍에서 객체는 기본적으로 변수를 가리킨다. 초기화: 선언과 동시에 값을 설정하는 것***

/*pA = *pA + 1; // 자료값을 통해 실제값을 변환시키는 방법./

=======================================================================

<구조체>
- 하나 이상의 서로 다른 종류의 변수들을 묶어서 새로운 자료형을 정의하는 것. 연관된 변수들을 하나로 묶어 관리하면 데이터 관리에 유용함.

=======================================================================

<동적 메모리 할당>
- 메모리 영역: 코드 영역, 스택 영역, 힙 영역, 데이터 영역(후입 선출 방식)=> 나중에 들어온 친구가 먼저 빠져나간다는 뜻.
- 힙 영역: 힙은 컴퓨터 메로리의 일부가 할당되었다가 회수되는 일들의 반복을 의미. 실행 시 사용자로부터 할당 메모리를 입력 받음.
- 프로그램 작성 시 얼마만큼의 메모리가 필요한지 알지 못하는 경우에 사용함.

***컴파일하는 시점과 실행하는 시점은 다르다. ***

===========================================================================
<<C++>> => 객체 지향 언어
- 추상화(사용자 정의 타입), 캡슐화 , 상속성(객체 수직관계(부모-자식)로 기존의 기능 가져오기 가능), 다형성(오버라이딩, 오버로딩) => C++ 철학 
- C와 C++의 차이: 인라인, 영역결정연산자(::), 함수 오버로딩, 연산자 오버로딩, 생성자 오버로딩.



<클래스>
- 사용자가 정의한 추상적인 데이터형(타입의 일종이다!!). 클래스를 통해 선언한 변수를 객체라고 한다. 기본 자료형 선언하듯이 선언하면 됨.
- 메모리 크기는 클래스가 담고 있는 변수의 데이터 합과 같다.
- 멤버 함수는 멤버 변수를 컨트롤 할 수 있는 유일한 게이트이다. 멤버함수는 반드시 객체와 붙어서 사용한다!! ex) mp1.getX(10, 20) 
- 멤버 함수가 아닌 다른 함수는 그러지 않아도 된다. 
- const 멤버함수는 객체의 멤버변수를 변경할 수 없는 읽기 전용 함수이다.

<생성자(constructor)>
-초기화: 기본 데이터를 선언과 동시에 초기 값을 대입하는 것(쓰레기 값 제거). 멤버 변수를 초기화시켜주고 싶을 때 사용.
- 구조체에서는 일반적인 초기화 가능하지만 객체 초기화하는데는 특별한 멤버함수가 필요. 기본 값으로 private가 설정되어 있기 때문.
- 필요 이유: 클래스 생성 시 매번 반복되는 초기화 멤버 함수를 만들어야 한다. 객체 생성 시 자동으로 초기화해주는 초기화 전용함수가 제공되는 데, 이를 생성자라고 한다.
- 생성자의 이름은 클래스의 이름과 동일. 타입 지정하지 않음(타입이 없음). 객체 선언 시 자동으로 호출. 인위적 호출 X. 반환값 지정하지 않아.
- 디폴트 생성자 존재. 생성자는 객체의 초기화를 위해 존재함. 기본적으로 C++에 내장되어 있음.
- 디폴트 생성자는 앞선 생성자와 같이 사용된다. 이때 두 함수는 오버로딩의 관계를 갖는다. 이때, 디폴트 생성자로만 값을 초기화하고 다른 생성자는 쓰지 않아도 무방함.

<소멸자>
- 클래스 이름과 같지만 앞에 ~기호가 붙는다. 타입 지정 X, 객체 소멸 시 자동으로 호출, 인위적으로 호출 불가.
- 반환값, 전달인자 지정 X. 생성자처럼 오버로딩이 되지 않는다. 스택 구조에 따라 선입후출의 순서로 소멸자가 소멸된다. 
- 객체들이 소멸할 때마다 소멸자가 호출된다.        


<객체 배열>
- 객체 = 개발자가 정의한 자료형 변수. 객체의 속성은 일반 변수의 속성과 동일함.

<객체 포인터>
- 객체의 주소값을 저장하기 위한 변수. 객체를 간접 참조하기 위해 사용.
- this는 객체를 가리키는 포인터이다.

cf) 포인터의 주소값은 언제나 4byte이다!(주소값은 언제나 정수로 받기 때문)

<static 멤버>
- 변수는 지역변수, 전역변수(시스템 종료 시 소멸) , static변수(지역 내 생성, 소멸은 시스템 종료)로 나뉨.
- 전역변수와 비슷한 성질을 가지면서도 클래스에 국한되어 사용된다. 지역 안에서의 전역변수.
- static 멤버 변수가 private 속성을 가지면 같은 클래스의 멤버함수에서만 접근 가능. 클래스 외부에서 접근 불가.
- C++에서 정적 멤버란 클래스에는 속하지만, 객체 별로 할당되지 않고 클래스의 모든 객체가 공유하는 멤버를 의미.
- 멤버 변수가 정적(static)으로 선언되면, 해당 클래스의 모든 객체에 대해 하나의 데이터만이 유지 관리된다.
- static 멤버함수는 객체와 무관하기 때문에 this 포인터가 의미가 없어짐.
- static 멤버함수는 특정 클래스 전체에 단 하나 존재하는 멤버 변수이기 때문에 프로그램 생성 시 한번 초기화되고 객체의 수에 따라 증가, 감소한다.

cf) const 멤버함수 안에서 일반 멤버함수를 호출할 수 없다(상수에서 변수를 호출할 수 없기 때문).

<new/delete 연산자와 동적 메모리>
- 동적메모리는 실행시간에 할당되어 사용되는 메모리 블록을 말한다. 주로 프로그램 작성 시 얼마만큼의 메모리가 필요한지 알지 못하는 경우에 사용됨.
- 동적 메모리 영역을 heap영역이라고 한다. 동적 메모리 생성 시 new 연산자를, 소멸 시 delete 연산자를 사용함. 소멸 안할 시 메모리 누수가 일어남. 
- C++에서는 힙 메모리에 동적 메로리를 할당할 때 new연산자를 사용한다. new연산자는 자신이 할당하는 객체의 데이터형을 알고 그 데이터형의 포인터를 반환한다.
- new연산자의 사용법: new + 타입. 주로 클래스가 쓰인다(객체 생성).


ex) int ar[100]: 스택메모리, 정적 /  new int ar[100]: 힙메로리, 동적 


<객체 포인터 배열>
- 여러 개의 객체를 관리하는 방법으로 배열을 선언하여 사용한 것. 포인터는 주소값만 저장할 수 있는 변수를 뜻한다.
- 각 기억 공간에 객체를 생성하여 주소값을 넘겨주는 식으로 사용된다.


<대입 연산자 오버로딩>
- 객체끼리의 대입 및 문제점: 같은 주소값을 갖는 것은 문제가 되지 않는다. 하지만 객체가 소멸할 때 치명적인 오류가 생긴다. 이를 해결하기 위해 대입 연산자 오버로딩을 사용한다.
- 기호가 같은 연산자가 여러가지 기능을 가질 수 있도록 만드는 것을 연산자 오버로딩이라고 한다.

<복사생성자>
- 객체 생성 시 초기화를 하되, 생성되는 객체를 다른 객체로 초기화 시에 호출한다. ex) String str2 = str1
- 복사 생성자의 특징은 함수명이 클래스와 동일하고 반환형이 없다는 것이다. 
- 대입연산자는 객체 생성 후 값을 대입하는 반면 복사생성자는 초기화 시에 복사(대입)을 진행한다는 것이다. 
- 또한 대입연산자는 기존 객체에서만 호출되지만 복사생성자는 새로운 객체를 만들 때 호출된다.


객체 지향: 사물을 지향하는 의미.(추상: 범위가 광범위한 경우)
 => 모든 사물을 프로그래밍화시키는 것을 목표로 함.

- 구조적 프로그래밍 방식: 순차적 프로그래밍방식(하향식). 기능단위: 함수.


- 객체지향 프로그래밍 방식: 기능단위 =객체, 사용자의 요청에 의해 처리되는 구조.

-추상: 대상에서 특징만을 뽑아낸 것.

-데이터 추상화: 사용자가 직접 사용자 정의 타입을 만들어 하나의 데이터 단위로 만든 것.

- 캡슐화: 은닉하다. 숨긴다는 의미.데이터를 외부로부터 숨긴다는 데이터 추상화와 일맥상통.(클래스 = 데이터 + 메소드)
           외부로부터 데이터를 조작할 인터페이스가 필요.	

=>데이터 숨김, 데이터 조작.

-다형성: 함수 이름이 같더라도 전달인자 타입, 개수 등에 따라 구분. **오버로딩과 오버라이딩 기법**이 있음.

- 오버로딩: 겉모습은 똑같지만 내용이 다른 경우. 이름이 같은 함수라도 전달인자 타입이나 개수가 다른 경우
  ex) 스타 오버로드(유닛에 따라 안은 다르지만 겉 모습은 똑같음. 안에 뭐가 있는지 바깥에선 모름) 


-오버라이딩: 무언가에 올라타서 기존의 것을 덮어 버린다는 개념. 상속의 개념이 기반이 되어야 함.

-상속성: 위로 갈수록 추상적, 아래로 갈수록 구체적.

<<출력객체 cout>>
- 이름공간에 대하여: 특정 공간에 이름을 지정해준다는 의미. namespace 지정.

**c언어에서는 변수선언이 무조건 전반부에 나타나야 하지만 c++은 변수 사용위치와 가까운 곳에 변수 선언이 가능)
**c++에서는 함수 선언부 매개변수에 기본값 설정 가능)

<<영역 결정 연산자>>
:: => 전역변수 받음.

<<인라인 함수>>

<<함수 오버로딩>>
- c언어에서는 함수의 이름을 기준으로 출력하기 때문에 같은 이름을 갖는 것이 불가능하다!!

<<클래스>>
- 추상적인 데이터형 => **본질은 데이터 타입** => 데이터 타입처럼 다루어주면 된다!!
- C언어의 구조체와 같은 논리. 거기에 함수도 포함되는 것이 클래스임.
- 구조체에서 멤버함수는 있을 필요가 없지만 클래스에서는 있어야 한다. 멤버함수가 없으면 멤버변수에 접근할 수가 없다!!
- 접근 지정자: private, public, protected. 
- private: 클래스 내에서만 접근 가능. 데이터 은닉. public: 외부에서도 접근이 가능함. 데이터의 은닉이 되지 않음.

<상속성>
- 객체 지향에서의 상속성: 완성된 하나의 데이터형인 클래스를 다른 클래스에 상속함으로써 기능을 제공하는 것.
- 장점: 계층의 명확성(클래스 간 역할 관계 명확하게 정의). 코드의 재사용성. 확장성
- 상속되지 않는 멤버: 생성자와 소멸자, friend 멤버.
- 멤버 함수의 오버라이딩: 부모 클래스에서 정의한 멤버 함수가 있다면  이를 자식 클래스에서 그대로 상속받되, 내용을 변경하여 새로운 기능을 만드는 것.
- 오버라이딩의 조건: 이름이 같아야 한다. 매개변수의 타입 및 개수가 같아야 한다. 반환 타입이 같아야 한다(오버라이딩: 덮어쓰다의 의미). =>완전히 똑같아야 한다.


<부모 클래스의 자식 클래스 객체 포인터 접근>
- 부모 클래스 객체 포인터를 통해 자식 클래스 객체 포인터를 제어. 부모 클래스를 통해 자식 클래스의 멤버변수와 멤버함수에 접근함.
- 멤버 변수는 그대로 접근 가능. 그러나 멤버 함수를 호출할 때는 추가적인 요소가 필요. 이를 해결하기 위해 가상함수 사용.


<다형성>
- 가상함수: 자식 클래스에서 오버라이딩될 것으로 예상되는 멤버함수. 자식함수에게 특정 멤버함수의 존재를 알려 이를 오버라이딩해서 사용할 수 있도록 권고하는 역할 수행.
- 상속관계에서 부모 클래스와 자식 클래스 모두에게 같은 이름의 멤버 함수가 존재하되, 자식 클래스의 멤버함수를 재정의 할 수있었음.
- 하지만 부모 클래스의 객체를 통해 자식 클래스에서 오버라이딩된 함수를 호출할 수는 없음. 가상함수는 이를 해결하기 위해 만든 개념.
- 동적결합: 함수 호출 시 클래스 객체에 따라 다른 값 호출. 객체가 정해지지 않음 <--> 정적 결합: 어떤 함수가 호출되는지 알 수 있음. 객체가 정해짐.
- 순수가상함수를 쓰게 되면 객체 생성이 안된다. 함수의 정의가 사라지면서 멤버함수의 사용이 막히기 때문에 객체 생성 자체를 미리 막아 놓는 것이다.
- 순수가상함수를 포함하는 클래스를 추상클래스라고 한다.
 

cf) 자바의 인터페이스: 100% 순수 가상함수로만 이뤄짐.


**클래스는 다중상속이 불가능하다. 단일 상속만 가능함. 모든 클래스는 하나의 책임만을 갖는다. 이러한 관점에서 클래스 트리 전체는 하나의 책임으로 묶인다.**


<템플릿>
- 다양한 타입이 모인 집합을 동적으로 타입을 결정하는 것. 템플릿의 철학은 누구나 공통적으로 사용하기 위한 일반화 프로그래밍을 기반으로 한다!!


<STL>
- STL: 표준 템플릿 라이브러리를 의미. 누구나 이해할 수 있는 코드를 짤 수 있도록 유도. 
- 컨테이너는 무언가를 담는 용기를 의미한다. 컨테이너는 배열처럼 동일한 요소들로 구성되어 있다. 컨테이너는 순차 컨테이너와 정렬 연관 컨테이너로 나뉜다.
- 순차 컨테이너: 벡터, 리스트 / 정렬 연관 컨테이너: 맵(key - value 구조)
- 반복자: 컨테이너의 요소를 가리키는 객체로 컨테이너의 시작부터 끝까지 이동하면서 요소를 읽거나 쓰기 위해 사용한다.
- 장점: 일반화를 지원한다. 단점: 가독성이 떨어진다.

<컨테이너> => 템플릿 기반
- 벡터: 필요한 크기만큼 메모리를 자동으로 재할당하여 늘릴 수 있다. 동적 배열의 개념과 동일.
- 리스트: 이중 연결 리스트로 구현된 컨테이너이다. 연결리스트는 포인터 변수인 노드가 붙어 있어서 논리적인 순서를 기억한다. 
	따라서 데이터 삽입, 삭제의 속도가 상대적으로 빠르다.  node 구조체는 연결리스트의 한 요소인 노드를 정의한다. 
	노드는 자신과 연결된 노드의 정보를 가지고 있으므로 물리적 메모리 이동 없이 링크만 조작하여 리스트 중간의 새로운 노드를 쉽게 삽입할 수 있다.
	노드의 삭제 역시 링크를 조작하는 방식으로 가능하다. 이중연결리스트는 앞 뒤의 노드 모두에 연결되는 리스트이다.
- 셋(set): 동일한 타입의 데이터를 모아 놓은 것. 데이터는 정렬된 위치에 삽입되므로 검색속도가 빠르고, 키가 중복되지 않는다. 일반 컨테이너와 사용형태는 동일하다.
- 맵: 두 개의 데이터가 하나의 쌍을 이루어 저장하는 컨테이너. 키-데이터 형태로 구성된다. 파이썬의 딕셔너리가 바로 맵 형태로 이뤄져 있다.

**배열과 연결리스트의 비교**
- 배열: 인접한 메모리 영역에 연속적으로 배치, 자신이 기억할 데이터 값만 갖는다.
- 연결 리스트: 요소들이 메모리 도처에 흩어져서 존재. 데이터 외에 연결 상태에 대한 정보인 링크를 추가로 가져야 한다. 포인터 주소로 서로를 연결한다. 

<반복자>
- 컨테이너(객체)의 구간에 대해 값을 읽어올 수 있도록 기능을 제공한다. 모든 컨테이너에 대해 동일하게 작동한다.
- 포인터와 상당히 흡사함. 어떤 컨테이너에 소속되어 있는지에 따라 그 종류가 다르다. 컨테이너의 구조가 다른만큼 거기에 맞춰 작동하기 때문이다.

<알고리즘>
- 알고리즘이란 컨테이너에 적용할 수 있는 기능들을 체계적으로 정리해 놓은 함수들을 말한다. 이 함수들은 일반적으로 사용된다.

<hash>
- 검색을 빠르게 하기 위해 만든 자료구조.
- hash_map: hash라는 자료구조를 통해 map의 검색속도가 빨라짐.

<싱글톤 패턴>
- 특정 클래스의 인스턴스를 1개만 생성하도록 제한하고, 이를 공유하는 방법.
- 생성자를 private로 하고, 자기 자신을 받는 함수를 만들어서 자기 자신의 객체를 반환하는 클래스.
- 프로그램 내에 특정 클래스 내에서 하나의 객체만 생성하고자 할 때 사용.
- 환경 설정 객체와 같이 공통으로 사용해야 하는 모듈에서 사용한다.

<스마트 포인터>
- 동적으로 할당한 데이터를 자동으로 해제할 수 있도록 함. 실수로 동적 메모리를 해제하는 delete 수행을 까먹을 시 유용. 
- 자동파괴자 auto_ptr: 객체 생성 시 사용했던 동적 메모리 또는 시스템 자원을 소멸 시 자동으로 소멸시키는 매커니즘 제공함.
		    동적으로 할당된 메모리도 자동으로 해제하는 포인터의 레퍼 클래스이다. 
- smart클래스 분석 : 생성자에서 t*p를 선언하는데 생성자에서 초기화시킨다. 객체 소멸 시 소멸자 내부에서는 포인터 p를 삭제시킴으로써 
		 p와 p가 가리키는 힙메모리까지 모두 정리된다.


#pragma once
- pragma once를 헤더 파일의 선두에 써두면 컴파일러는 딱 한번만 헤더 파일을 포함한다.

**포인터와 참조자를 구분하여 사용하자**
-참조자는 반드시 초기화 되어야 한다.
- 참조자는 유효성을 검사할 필요가 없다.
- 포인터는 객체의 유효성을 검사하여야 한다.

***객체지향적 사고 습관***
- 기본적인 컨셉: 공통점 묶기, 조금만 알기.


===================================================================================================

<<<파이썬>>>
- 파이썬 역시 객체지향언어로 객체를 주로 이용한다. 우리가 변수 선언으로 아는 것이 사실은 객체 선언이다!! ex) type(a) => class 'str'
- 문자에 맵핑한 숫자인 아스키 코드를 제공한다.

<리스트>
- 임의의 정보들을 순서대로 나열하여 보여주는 형태를 리스트라고 한다. 문법은 배열의 형태로 작동한다. 자료구조는 리스트 형태를 유지한다.
- 리스트는 대괄호 안에 값들을 선언한다. 리스트는 연산이 가능하다. 이것은 리스트끼리의 오버로딩으로 가능하다.

<튜플>
- 리스트와 비슷하지만 값을 읽기만 가능하다는 점에서 다르다. c++의 const 함수와 동일한 기능.
- 튜플이름[시작인덱스 : 끝 인덱스 + 1] 등 리스트와 기능 동일. 
- 튜플을 리스트로 전환 가능. 또한 리스트도 튜플로 전환 가능 ex)list(튜플), tuple(리스트)

<딕셔너리>
- key와 value로 관리되는 자료구조. c++의 map과 동일함. 

***key-value 구조: value 값을 쉽게 찾기 위해 key를 부여한 것**

**인코딩: 암호화, 디코딩: 해독화**

<데이터베이스>
- 데이터 베이스는 그 자체로 서버이다. 구조화된 형태로 안전하고 빠르게 보관하고 사용할 수 있다.
- 기존 프로그램들은 데이터를 사용하지만 저장하지는 않았음. 구조화가 되어 있지 않아 관리에 한계 존재.
- 데이터베이스는 데이터를 관리하는 모든 시스템을 의미하고, 오라클이나 몽고db 같은 시스템은 데이터베이스 관리 시스템을 의미한다.
- 관계형 데이터베이스는 데이터의 x, y의 상관관계를 갖는 2차원 구조를 말한다. 데이터구조는 2차원배열과 같은 구조를 갖는다.
- 데이터베이스는 파일처럼 데이터를 무조건 저장하는 것이 아니라 체계적으로 사용하기 위한 구조를 설계해야 한다. 이를 데이터베이스 모델링이라고 한다.
- 데이터베이스의 정보들은 구조화된 형태로 저장되야 하는데, 기본적으로 테이블(table)이라는 요소에 표 형식의 틀에 맞추어 저장하고 읽을 수 있다.
- 데이터가 모인 형태를 스키마라고도 부른다.
- SQL: 데이터베이스를 조작할 수 있는 공통적인 데이터베이스 전용 언어. 기본적인 기능은 CRUD가 있다. 
