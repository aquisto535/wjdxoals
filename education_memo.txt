<<C언어>>

컴파일러, 포인터, 

빌드의 의미: 컴파일링에 성공해 컴퓨터가 이해할 수 있는 이진수로 만드는 것.
전처리기: 컴파일 이전 단계
함수: 표준함수와 사용자 정의 함수 두 종류.
긴 주석: /* */. 날짜, 작성자, 설명 등 기술.
함수 주석: 테스트용으로도 사용가능. 특정함수를 잠시 빼서 실행시키는 용도.
\n: 한 줄 씩 띄어쓰게 하기.

============================================================

<변수형>
변수: 변경이 가능한 수. 메모리 안에서 특정한 주소값을 가짐.하지만 모든 변수의 주소값을 기억할 수 없음. 따라서 의미있는 이름(변수명)을 부여하는 것임.
컴퓨터 구조: 디스크(프로그램), 메모리(프로세스)-RAM, CPU. CPU가 메모리와 데이터를 주고받을 때는 주소(포인터 변수)를 사용.
변수 선언의 기본 형태: 자료형-변수명(int-value)
코딩에서의 '='의 의미: 대입 ex) a = b => b가 a에 들어간다. 변수값이 변수에 들어가는 것.

int value; value = 100 (쓰레기 값을 100으로 변환) int value = 100(초기화 후 값 지정, 더 나음)

C언어에서 변수 지정 방식

1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성됩니다.

2. 변수의 이름은 숫자로 시작될 수 없습니다.

3. 변수의 이름 사이에는 공백을 포함할 수 없습니다.

4. 변수의 이름으로 C언어에서 미리 정의된 키워드(keyword)는 사용할 수 없습니다.

==============================================================

<자료형>

실수:double, 정수: int, 문자열: char.

*** 문자형과 문자열의 차이: 'A' = 문자형. 'Hello' = 문자열 ***

#{}:param이 자동적으로 string형태로 들어온다.
${}:param이 해당 컬럼의 자료형에 맞추어 파라미터의 자료형이 변경된다. 쿼리문으로 인식

상수: 변경 불가한 값. 메모리에 올라가 있음(연산 가능한 이유)

키보드(입력) => 메인보드 => 운영체제 => 프로그램

데이터의 주소값이란 해당 데이터가 저장된 메모리의 시작 주소를 의미한다.
주소변산자: &변수 => 변수의 데이터 주소를 보여줌(scanf_s)

**scanf_s("서식문자열(나타날 결과)", 변수) **

연산자: 정적인 데이터들을 유기적으로 행동하게 하여 새로운 가치를 창출해내는 것
- 대입 연산자: 대입연산자는 오른쪽에 있는 값을 왼쪽에 대입하는 역할을 한다. ex) a+=b => a = a + b
- 증감 연산자: 증가 연산자와 감소 연산자의 줄임말. ex) ++a: a의 값을 1 증가시킨 후 연산 진행. a++: 연산을 진행한 후 값을 1 증가시킨다.

*서식: 일정한 방식, 틀(함수)
서식 지정자: 변수를 이용하여 사용하는 지정자. 서식이 있을 때에만 변수를 옆에 적어준다. 서식이 없을 때는 따옴표 안의 내용만으로도 출력이 가능하다.

================================================================

<조건문>
- 조건을 최대한 촘촘하게 설정하자. 그렇지 않으면 내가 예상한 범위 밖의 값이 그대로 통과될 수도 있다. 
- 범위가 너무 넓으면 나누기를 통해서 그 범위를 축소하는 편이 좋다. ex)100점 => 100 / 10 = 10으로 축약(case10). if문과 swich문 모두에서 편리함.
- 홀수 짝수 구분 = 2로 나누었을 때 나머지가 0이면 짝수 1이면 홀수. 또는 a = a+ 2의 형태로 짝수만 나오게 유도할 수 있다.


 ================================================================

<반복문>
- for문, while문 매우 중요!!

**누적 계산법 => sum = sum + 변수**

=================================================================

<함수>
- void 함수는 결과값을 반환하지 않아서 다른 함수에서 결과값을 참조할 수 없다!! 쓰려면 main함수에서 void함수를 실행만 시켜주는 식으로 써야 한다!

====================================================================

<배열>
- 컴파일 시점에서 배열 안에 서식 문자를 쓰게 되면 그 문자의 값이 나중에 설정되는 경우에 컴파일러가 배열의 값을 인식하지 못한다. 따라서 c언어는 
 배열의 첫번째 요소를 무조건 0부터 시작하고, 인덱스도 0부터 시작한다.

- sizeof: 배열의 길이 구하는 연산자. ex) sizeof(int) = 4( bite크기로 계산함). sizeof(arr[3]) = 12; 배열의 길이 = sizeof(배열) / sizeof(배열[0]) => 전체 길이 / 한 요소의 길이. 

- 문자열: 문자열은 ""로 사용한다. 배열의 이름 == 주소값. 정의된 문자열은 변수 상태로 존재. 초기화 못시키기 때문에 일부러 null 값(\0)을 넣어 쓰레기값과 거리를 둠.유효 값만 인식. 
          
**인덱스의 길이는 5이지만 마지막 배열의 인덱스는 4이다!!**

- 배열의 이름 = 포인터. 배열의 첫 번째 주소값과 값이 같음. 다만 값을 변경할 수 없음(상수); 포인터를 배열처럼 사용. 

- 배열 이름을 포인터처럼 사용함. 포인터와 배열은 불가분 관계. 서로가 밀접하게 연결되어 있다.


======================================================================

<포인터>
-*는 포인터 변수를 지칭하는 기호. 이것을 쓰지 않으면 변수의 주소값을 받을 수 없다. 이 변수는 주소값과 변수의 실제값 둘 다 호출할 수 있다. 
 주소값을 호출할 때는 그냥 기호를 쓰고, 실제값을 호출할 때는 *를 붙여서 써준다. 

- &a는 a의 주소값을 가리킨다. 또한 배열의 이름은 배열의 첫번째 요소의 포인터를 의미한다. 

- 주소값은 기본적으로 정수값이다. 따라서 4바이트를 할당한다. 포인터 변수와 일반변수는 서로 자료형이 똑같아야 한다. 그렇지 않으면 실제값을 가져올 수 없다.

*** 프로그래밍에서 객체는 기본적으로 변수를 가리킨다. 초기화: 선언과 동시에 값을 설정하는 것***

/*pA = *pA + 1; // 자료값을 통해 실제값을 변환시키는 방법./

=======================================================================

<구조체>
- 하나 이상의 서로 다른 종류의 변수들을 묶어서 새로운 자료형을 정의하는 것. 연관된 변수들을 하나로 묶어 관리하면 데이터 관리에 유용함.

=======================================================================

<동적 메모리 할당>
- 메모리 영역: 코드 영역, 스택 영역, 힙 영역, 데이터 영역(후입 선출 방식)=> 나중에 들어온 친구가 먼저 빠져나간다는 뜻.
- 힙 영역: 힙은 컴퓨터 메로리의 일부가 할당되었다가 회수되는 일들의 반복을 의미. 실행 시 사용자로부터 할당 메모리를 입력 받음.
- 프로그램 작성 시 얼마만큼의 메모리가 필요한지 알지 못하는 경우에 사용함.

***컴파일하는 시점과 실행하는 시점은 다르다. ***

===========================================================================
<<C++>> => 객체 지향 언어
- 추상화(사용자 정의 타입), 캡슐화 , 상속성(객체 수직관계(부모-자식)로 기존의 기능 가져오기 가능), 다형성(오버라이딩, 오버로딩) => C++ 철학 
- C와 C++의 차이: 인라인, 영역결정연산자(::), 함수 오버로딩, 연산자 오버로딩, 생성자 오버로딩.



<클래스>
- 사용자가 정의한 추상적인 데이터형(타입의 일종이다!!). 클래스를 통해 선언한 변수를 객체라고 한다. 기본 자료형 선언하듯이 선언하면 됨.
- 메모리 크기는 클래스가 담고 있는 변수의 데이터 합과 같다.
- 멤버 함수는 멤버 변수를 컨트롤 할 수 있는 유일한 게이트이다. 멤버함수는 반드시 객체와 붙어서 사용한다!! ex) mp1.getX(10, 20) 
- 멤버 함수가 아닌 다른 함수는 그러지 않아도 된다. 
- const 멤버함수는 객체의 멤버변수를 변경할 수 없는 읽기 전용 함수이다.

<생성자(constructor)>
-초기화: 기본 데이터를 선언과 동시에 초기 값을 대입하는 것(쓰레기 값 제거). 멤버 변수를 초기화시켜주고 싶을 때 사용.
- 구조체에서는 일반적인 초기화 가능하지만 객체 초기화하는데는 특별한 멤버함수가 필요. 기본 값으로 private가 설정되어 있기 때문.
- 필요 이유: 클래스 생성 시 매번 반복되는 초기화 멤버 함수를 만들어야 한다. 객체 생성 시 자동으로 초기화해주는 초기화 전용함수가 제공되는 데, 이를 생성자라고 한다.
- 생성자의 이름은 클래스의 이름과 동일. 타입 지정하지 않음(타입이 없음). 객체 선언 시 자동으로 호출. 인위적 호출 X. 반환값 지정하지 않아.
- 디폴트 생성자 존재. 생성자는 객체의 초기화를 위해 존재함. 기본적으로 C++에 내장되어 있음.
- 디폴트 생성자는 앞선 생성자와 같이 사용된다. 이때 두 함수는 오버로딩의 관계를 갖는다. 이때, 디폴트 생성자로만 값을 초기화하고 다른 생성자는 쓰지 않아도 무방함.

<소멸자>
- 클래스 이름과 같지만 앞에 ~기호가 붙는다. 타입 지정 X, 객체 소멸 시 자동으로 호출, 인위적으로 호출 불가.
- 반환값, 전달인자 지정 X. 생성자처럼 오버로딩이 되지 않는다. 스택 구조에 따라 선입후출의 순서로 소멸자가 소멸된다. 
- 객체들이 소멸할 때마다 소멸자가 호출된다.        


<객체 배열>
- 객체 = 개발자가 정의한 자료형 변수. 객체의 속성은 일반 변수의 속성과 동일함.

<객체 포인터>
- 객체의 주소값을 저장하기 위한 변수. 객체를 간접 참조하기 위해 사용.
- this는 객체를 가리키는 포인터이다.

cf) 포인터의 주소값은 언제나 4byte이다!(주소값은 언제나 정수로 받기 때문)

<static 멤버>
- 변수는 지역변수, 전역변수(시스템 종료 시 소멸) , static변수(지역 내 생성, 소멸은 시스템 종료)로 나뉨.
- 전역변수와 비슷한 성질을 가지면서도 클래스에 국한되어 사용된다. 지역 안에서의 전역변수.
- static 멤버 변수가 private 속성을 가지면 같은 클래스의 멤버함수에서만 접근 가능. 클래스 외부에서 접근 불가.
- C++에서 정적 멤버란 클래스에는 속하지만, 객체 별로 할당되지 않고 클래스의 모든 객체가 공유하는 멤버를 의미.
- 멤버 변수가 정적(static)으로 선언되면, 해당 클래스의 모든 객체에 대해 하나의 데이터만이 유지 관리된다.
- static 멤버함수는 객체와 무관하기 때문에 this 포인터가 의미가 없어짐.
- static 멤버함수는 특정 클래스 전체에 단 하나 존재하는 멤버 변수이기 때문에 프로그램 생성 시 한번 초기화되고 객체의 수에 따라 증가, 감소한다.

cf) const 멤버함수 안에서 일반 멤버함수를 호출할 수 없다(상수에서 변수를 호출할 수 없기 때문).

<new/delete 연산자와 동적 메모리>
- 동적메모리는 실행시간에 할당되어 사용되는 메모리 블록을 말한다. 주로 프로그램 작성 시 얼마만큼의 메모리가 필요한지 알지 못하는 경우에 사용됨.
- 동적 메모리 영역을 heap영역이라고 한다. 동적 메모리 생성 시 new 연산자를, 소멸 시 delete 연산자를 사용함. 소멸 안할 시 메모리 누수가 일어남. 
- C++에서는 힙 메모리에 동적 메로리를 할당할 때 new연산자를 사용한다. new연산자는 자신이 할당하는 객체의 데이터형을 알고 그 데이터형의 포인터를 반환한다.
- new연산자의 사용법: new + 타입. 주로 클래스가 쓰인다(객체 생성).


ex) int ar[100]: 스택메모리, 정적 /  new int ar[100]: 힙메로리, 동적 


<객체 포인터 배열>
- 여러 개의 객체를 관리하는 방법으로 배열을 선언하여 사용한 것. 포인터는 주소값만 저장할 수 있는 변수를 뜻한다.
- 각 기억 공간에 객체를 생성하여 주소값을 넘겨주는 식으로 사용된다.


<대입 연산자 오버로딩>
- 객체끼리의 대입 및 문제점: 같은 주소값을 갖는 것은 문제가 되지 않는다. 하지만 객체가 소멸할 때 치명적인 오류가 생긴다. 이를 해결하기 위해 대입 연산자 오버로딩을 사용한다.
- 기호가 같은 연산자가 여러가지 기능을 가질 수 있도록 만드는 것을 연산자 오버로딩이라고 한다.

<복사생성자>
- 객체 생성 시 초기화를 하되, 생성되는 객체를 다른 객체로 초기화 시에 호출한다. ex) String str2 = str1
- 복사 생성자의 특징은 함수명이 클래스와 동일하고 반환형이 없다는 것이다. 
- 대입연산자는 객체 생성 후 값을 대입하는 반면 복사생성자는 초기화 시에 복사(대입)을 진행한다는 것이다. 
- 또한 대입연산자는 기존 객체에서만 호출되지만 복사생성자는 새로운 객체를 만들 때 호출된다.

<상속성>
- 객체 지향에서의 상속성: 완성된 하나의 데이터형인 클래스를 다른 클래스에 상속함으로써 기능을 제공하는 것.
- 장점: 계층의 명확성(클래스 간 역할 관계 명확하게 정의). 코드의 재사용성. 확장성
- 상속되지 않는 멤버: 생성자와 소멸자, friend 멤버.
- 멤버 함수의 오버라이딩: 부모 클래스에서 정의한 멤버 함수가 있다면  이를 자식 클래스에서 그대로 상속받되, 내용을 변경하여 새로운 기능을 만드는 것.
- 오버라이딩의 조건: 이름이 같아야 한다. 매개변수의 타입 및 개수가 같아야 한다. 반환 타입이 같아야 한다(오버라이딩: 덮어쓰다의 의미). =>완전히 똑같아야 한다.

<부모 클래스의 자식 클래스 객체 포인터 접근>
- 부모 클래스 객체 포인터를 통해 자식 클래스 객체 포인터를 제어.


<다형성>
- 가상함수: 자식 클래스에서 오버라이딩될 것으로 예상되는 멤버함수.
- 상속관계에서 부모 클래스와 자식 클래스 모두에게 같은 이름의 멤버 함수가 존재하되, 자식 클래스의 멤버함수를 재정의 할 수있었음.
- 하지만 부모 클래스의 객체를 통해 자식 클래스에서 오버라이딩된 함수를 호출할 수는 없음. 가상함수는 이를 해결하기 위해 만든 개념.





<<<파이썬>>>
- 파이썬 역시 객체지향언어로 객체를 주로 이용한다. 우리가 변수 선언으로 아는 것이 사실은 객체 선언이다!! ex) type(a) => class 'str'
- 문자에 맵핑한 숫자인 아스키 코드를 제공한다.



