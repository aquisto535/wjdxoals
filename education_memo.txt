<<C언어>>

컴파일러, 포인터, 

빌드의 의미: 컴파일링에 성공해 컴퓨터가 이해할 수 있는 이진수로 만드는 것.
전처리기: 컴파일 이전 단계
함수: 표준함수와 사용자 정의 함수 두 종류.
긴 주석: /* */. 날짜, 작성자, 설명 등 기술.
함수 주석: 테스트용으로도 사용가능. 특정함수를 잠시 빼서 실행시키는 용도.
\n: 한 줄 씩 띄어쓰게 하기.

============================================================
<변수형>
변수: 변경이 가능한 수. 메모리 안에서 특정한 주소값을 가짐.하지만 모든 변수의 주소값을 기억할 수 없음. 따라서 의미있는 이름(변수명)을 부여하는 것임.
컴퓨터 구조: 디스크(프로그램), 메모리(프로세스)-RAM, CPU. CPU가 메모리와 데이터를 주고받을 때는 주소(포인터 변수)를 사용.
변수 선언의 기본 형태: 자료형-변수명(int-value)
코딩에서의 '='의 의미: 대입 ex) a = b => b가 a에 들어간다. 변수값이 변수에 들어가는 것.

int value; value = 100 (쓰레기 값을 100으로 변환) int value = 100(초기화 후 값 지정, 더 나음)

C언어에서 변수 지정 방식

1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성됩니다.

2. 변수의 이름은 숫자로 시작될 수 없습니다.

3. 변수의 이름 사이에는 공백을 포함할 수 없습니다.

4. 변수의 이름으로 C언어에서 미리 정의된 키워드(keyword)는 사용할 수 없습니다.

==============================================================
<자료형>

실수:double, 정수: int, 문자열: char.

*** 문자형과 문자열의 차이: 'A' = 문자형. 'Hello' = 문자열 ***

#{}:param이 자동적으로 string형태로 들어온다.
${}:param이 해당 컬럼의 자료형에 맞추어 파라미터의 자료형이 변경된다. 쿼리문으로 인식

상수: 변경 불가한 값. 메모리에 올라가 있음(연산 가능한 이유)

키보드(입력) => 메인보드 => 운영체제 => 프로그램

데이터의 주소값이란 해당 데이터가 저장된 메모리의 시작 주소를 의미한다.
주소변산자: &변수 => 변수의 데이터 주소를 보여줌(scanf_s)

**scanf_s("서식문자열(나타날 결과)", 변수) **

연산자: 정적인 데이터들을 유기적으로 행동하게 하여 새로운 가치를 창출해내는 것
- 대입 연산자: 대입연산자는 오른쪽에 있는 값을 왼쪽에 대입하는 역할을 한다. ex) a+=b => a = a + b
- 증감 연산자: 증가 연산자와 감소 연산자의 줄임말. ex) ++a: a의 값을 1 증가시킨 후 연산 진행. a++: 연산을 진행한 후 값을 1 증가시킨다.

*서식: 일정한 방식, 틀(함수)
서식 지정자: 변수를 이용하여 사용하는 지정자. 서식이 있을 때에만 변수를 옆에 적어준다. 서식이 없을 때는 따옴표 안의 내용만으로도 출력이 가능하다.

================================================================
<조건문>
- 조건을 최대한 촘촘하게 설정하자. 그렇지 않으면 내가 예상한 범위 밖의 값이 그대로 통과될 수도 있다. 
- 범위가 너무 넓으면 나누기를 통해서 그 범위를 축소하는 편이 좋다. ex)100점 => 100 / 10 = 10으로 축약(case10). if문과 swich문 모두에서 편리함.
- 홀수 짝수 구분 = 2로 나누었을 때 나머지가 0이면 짝수 1이면 홀수. 또는 a = a+ 2의 형태로 짝수만 나오게 유도할 수 있다.


 ================================================================
<반복문>
- for문, while문 매우 중요!!

**누적 계산법 => sum = sum + 변수**
=================================================================
<함수>
- void 함수는 결과값을 반환하지 않아서 다른 함수에서 결과값을 참조할 수 없다!! 쓰려면 main함수에서 void함수를 실행만 시켜주는 식으로 써야 한다!

====================================================================
<배열>
- 컴파일 시점에서 배열 안에 서식 문자를 쓰게 되면 그 문자의 값이 나중에 설정되는 경우에 컴파일러가 배열의 값을 인식하지 못한다. 따라서 c언어는 
 배열의 첫번째 요소를 무조건 0부터 시작하고, 인덱스도 0부터 시작한다.

- sizeof: 배열의 길이 구하는 연산자. ex) sizeof(int) = 4( bite크기로 계산함). sizeof(arr[3]) = 12; 배열의 길이 = sizeof(배열) / sizeof(배열[0]) => 전체 길이 / 한 요소의 길이. 
- 문자열: 문자열은 ""로 사용한다. 배열의 이름 == 주소값. 정의된 문자열은 변수 상태로 존재. 초기화 못시키기 때문에 일부러 null 값(\0)을 넣어 쓰레기값과 거리를 둠.유효 값만 인식. "


===========================================================================
<<C++>>
- 추상화, 캡슐화 , 상속성, 다형성(오버라이딩, 오버로딩) => C++ 철학 
- C와 C++의 차이: 인라인, 영역결정연산자(::), 함수 오버로딩, 연산자 오버로딩, 생성자 오버로딩.


<클래스>
- 사용자가 정의한 추상적인 데이터형. 클래스를 통해 선언한 변수를 객체라고 한다. 기본 자료형 선언하듯이 선언하면 됨.
- 메모리 크기는 클래스가 담고 있는 변수의 데이터 합과 같다.
- 멤버 함수는 멤버 변수를 컨트롤 할 수 있는 유일한 게이트이다.

<생성자(constructor)>
-초기화: 기본 데이터를 선언과 동시에 초기 값을 대입하는 것(쓰레기 값 제거). 
- 구조체에서는 일반적인 초기화 가능하지만 객체 초기화하는데는 특별한 멤버함수가 필요. 기본 값으로 private가 설정되어 있기 때문.
- 필요 이유: 클래스 생성 시 매번 반복되는 초기화 멤버 함수를 만들어야 한다. 객체 생성 시 자동으로 초기화해주는 초기화 전용함수가 제공되는 데, 이를 생성자라고 한다.
- 생성자의 이름은 클래스의 이름과 동일. 타입 지정하지 않음(타입이 없음). 객체 선언 시 자동으로 호출. 인위적 호출 X. 반환값 지정하지 않아.
- 디폴트 생성자 존재. 생성자는 객체의 초기화를 위해 존재함.
- 디폴트 생성자는 앞선 생성자와 같이 사용된다. 이때 두 함수는 오버로딩의 관계를 갖는다. 이때, 디폴트 생성자로만 값을 초기화하고 다른 생성자는 쓰지 않아도 무방함.

<소멸자>
- 클래스 이름과 같지만 앞에 ~기호가 붙는다. 타입 지정 X, 객체 소멸 시 자동으로 호출, 인위적으로 호출 불가.
- 반환값, 전달인자 지정 X. 생성자처럼 오버로딩이 되지 않는다. 스택 구조에 따라 선입후출의 순서로 소멸자가 소멸된다. 
- 객체들이 소멸할 때마다 소멸자가 호출된다. 


<객체 배열>
- 객체 = 개발자가 정의한 자료형 변수. 



